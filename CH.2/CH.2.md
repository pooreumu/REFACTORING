# CHAPTER 02 리팩터링 원칙

## 2.1 리팩터링 정의

> 리팩터링: [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법

앞 장에서 본 **함수 추출하기**와 **조건부 로직을 다형성으로 바꾸기**처럼 이름 붙은 리팩터링 기법들이 이 정의에 해당한다.

> 리팩터링(하다): [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성한다.

리팩터링은 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰변화를 만들어내는 일이다. 따라서 리팩터링하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있다.

> 누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했다"라고 한다면, 십중팔구 리팩터링한 것이 아니다.

## 2.3 리팩터링 하는 이유

### 리팩터링하면 소프트웨어 설계가 좋아진다

규칙적인 리팩터링은 코드의 구조를 지탱해줄 것이다.

### 리팩터링하면 소프트웨어를 이해하기 쉬워진다

코드의 목적이 더 잘 드러나게, 다시 말해 내 의도를 더 명확하게 전달하도록 개선할 수 있다.

### 리팩터링하면 버그를 쉽게 찾을 수 있다

### 리팩터링하면 프로그래밍 속도를 높일 수 있다

## 2.4 언제 리팩터링해야 할까?

> 3의 법칙
>
> 돈 로버츠(Don Roberts)가 제시한 가이드
>
> 1. 처음에는 그냥 한다.
> 2. 비슷한 일을 두 번째로 하게 되면(중복이 생겼다는 사실에 당활스럽겠지만), 일단 계속 진행한다.
> 3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.

### 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기

리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다.

### 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기

코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다.

조건부 로직의 구조가 이상하지 않은지 살펴보거나, 함수 이름을 적절한 이름으로 바꿔주거나

### 쓰레기 줍기 리팩터링

로직이 쓸데업이 복잡하거나, 매개변수화한 함수 하나면 될 일을 거의 똑같은 함수 여러 개로 작성해놨을 수 있다.

### 계획된 리팩터링과 수시로 하는 리팩터링

> 보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.

> 무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고(단, 만만치 않을 수 있다) 그런 다음 쉽게 수정하자.

뛰어난 개발자는 새 기능을 추가하기 쉽도록 코드를 '수정'하는 것이 그 기능을 가장 빠르게 추가하는 길일 수 있음을 안다.

### 오래 걸리는 리팩터링

라이브러리를 새 것으로 교체하는 작업이나, 그동안 작업하면서 쌓여온 골치 아픈 의존성을 정리하는 작업일 수도 있다.

이런 상황에 처하더라도 팀 전체가 리팩터링에 매달리는 데는 회의적이다.

### 코드 리뷰에 리팩터링 활용하기

코드 리뷰에 리팩터링을 접목하는 구체적인 방법은 리뷰의 성격에 따라 다르다. 흔히 쓰는 PR(코드 작성자 없이 검토하는 방식)에서는 그리 효과적이지 않다. 코드 작성자가 참석해야 맥락을 설명해줄 수 있고 작성자도 리뷰어의 변경 의도를 제대로 이해할 수 있으므로, 이왕이면 참석자가 참석하는 방식이 좋다.

작가가 경험한 가장 좋은 방법은 pair programming이다.

### 관리자에게는 뭐라고 말해야 할까?

> 리팩터링한다고 말하지 말라

### 리팩터링하지 말아야 할 때

-   굳이 수정할 필요가 없을 때, 외부 API 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 둔다. 내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다.
-   리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때

## 2.5 리팩터링 시 고려할 문제

### 새 기능 개발 속도 저하

> 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.

### 코드 소유권

작가가 선호하는 방식은 코드의 소유권을 팀에 두는 것 그래서 팀원이라면 누구나 팀이 소유한 코드를 수정할 수 있게 한다.

### 브랜치

-   마스터와 통합 자주해라(CI, TBD)
-   기능 토글(feature toggle), 기능 플래그(feature flag)를 적용하여 완료되지 않은 기능이 시스템 전체를 망치지 않도록 해야 한다.
-   CI는 리팩터링과 궁합이 좋다.
-   켄트 벡이 CI와 리팩터링을 합쳐서 익스트림 프로그래밍을 만든 이유도 바로 두 기법의 궁합이 잘 맞기 때문이다.

### 테스팅

-   리팩터링의 두드러진 특성은 프로그램의 겉보기 동작은 똑같이 유지된다는 것이다.
-   자가 테스트 코드는 리팩터링을 할 수 있게 해줄 뿐만 아니라, 새 기능 추가도 훨씬 안적하게 진행할 수 있도록 도와준다.
-   리팩터링 과정에서 버그가 생길 위험이 아주 크다는 불안감을 해소할 수 있다.

### 레거시 코드

-   대규모 레거시 시스템을 테스트 코드 없이 명로하게 리팩터링하기는 어렵다.
-   테스트를 갖추고 있더라도 복잡하게 얽힌 레거시 코드를 아름다운 코드로 단번에 리팩터링하는 데는 낙관적이지 않다.
-   서로 관련된 부분끼리 나눠서 하나씩 공략하는 것이다.

### 데이터베이스

-   프라모드 사달게가 개발한 진화형 데이터베이스 설계와 데이터베이스 리팩터링 기법은 현재 널리 적용되고 있다
-   필드이름을 바꿀 때 첫번쩨 커밋에서는 새로은 데이터베이스 필드를 추가만 하고 사용하지는 않는다.
-   기존 필드와 새 필드를 동시에 업데이트 하도록 설정한다.
-   데이터베이스를 읽는 클라이언트들을 새 필드를 사용하는 버전으로 조금씩 교체한다.
-   더는 필요가 없어진 예전 필드를 삭제한다.
